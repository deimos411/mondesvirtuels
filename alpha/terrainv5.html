<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Free Web tutorials" />
    <meta
      name="keywords"
      content="BabylonJS, 3D, landscape, procedural, HTML, CSS, JavaScript"
    />
    <meta name="author" content="Josquin BERNARD" />
    <link rel="canonical" href="https://virtualworlds.fun/" />
    <title>3D Natural Landscape</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      .controls {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px;
        border-radius: 8px;
        z-index: 1000;
        max-width: 300px;
      }

      .controls h2 {
        margin-bottom: 10px;
        font-size: 16px;
      }

      .controls p {
        font-size: 14px;
        margin-bottom: 8px;
        line-height: 1.4;
      }

      .fps-counter {
        position: fixed;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 16px;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
      }

      .edit-radius-controls {
        position: fixed;
        top: 70px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 1000;
      }

      .radius-button {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
        position: relative;
      }

      .radius-button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 10px;
        transform: translateY(-50%);
        width: 10px;
        height: 10px;
        background: yellow;
        border-radius: 50%;
      }

      /* Active class for Tool Size buttons */
      .radius-button.active-tool {
        background: rgba(255, 0, 157, 0.3);
      }

      /* Active class for Load/Reset/Random buttons */
      .radius-button.active-action {
        background: rgba(
          0,
          255,
          0,
          0.3
        ); /* Use a different color for distinction */
      }

      /* Exclude Load and Save buttons from the yellow round */
      .save-load-controls .radius-button::before {
        display: none;
      }
      .radius-button.small::before {
        width: 8px;
        height: 8px;
      }

      .radius-button.medium::before {
        width: 12px;
        height: 12px;
      }

      .radius-button.large::before {
        width: 16px;
        height: 16px;
      }

      @media (max-width: 768px) {
        .controls {
          top: auto;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          width: 90%;
          max-width: none;
        }
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 2000;
        text-align: center;
      }

      .save-load-controls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
        z-index: 1000;
      }

      /* New CSS for season controls */
      .season-controls {
        position: fixed;
        top: 20px;
        right: 70px; /* Adjust this value to position the buttons */
        display: flex;
        gap: 10px;
        z-index: 1000;
      }

      .season-button {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px;
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
        border: none;
        outline: none;
      }

      .season-button.active {
        background: rgba(255, 255, 0, 0.3);
      }

      .action-button {
        font-size: 14px;
      }

      button,
      .radius-button,
      .season-button {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <div class="controls2">
      <h2>Camera Controls</h2>
      <p>Left Click + Drag: Rotate camera</p>
      <p>Right Click + Drag: Pan camera</p>
      <p>Mouse Wheel: Zoom in/out</p>
      <p>Touch: One finger to rotate, two fingers to zoom</p>
    </div>
    <div id="loadingScreen" class="loading">Loading Scene...</div>

    <!-- New season buttons -->
    <div class="season-controls">
      <button
        id="springButton"
        class="season-button"
        alt="Spring"
        title="Spring"
      >
        S
      </button>
      <button
        id="summerButton"
        class="season-button"
        alt="Summer"
        title="Summer"
      >
        S
      </button>
      <button
        id="autumnButton"
        class="season-button"
        alt="Autumn"
        title="Autumn"
      >
        A
      </button>
      <button
        id="winterButton"
        class="season-button"
        alt="Winter"
        title="Winter"
      >
        W
      </button>
    </div>

    <!-- FPS counter -->
    <div id="fpsCounter" class="fps-counter">FPS: 0</div>
    <div class="edit-radius-controls">
      <div
        class="radius-button small"
        data-radius="50"
        alt="Small radius tool"
        title="Small radius tool"
      ></div>
      <div
        class="radius-button medium"
        data-radius="150"
        alt="Medium radius tool"
        title="Medium radius tool"
      ></div>
      <div
        class="radius-button large"
        data-radius="300"
        alt="Big radius tool"
        title="Big radius tool"
      ></div>
    </div>
    <div class="save-load-controls">
      <button id="randomButton" class="action-button">Random</button>
      <button id="resetButton" class="action-button">Reset</button>
      <button id="saveButton" class="action-button">Save</button>
      <button id="loadButton" class="action-button">Load</button>
      <input type="file" id="loadFile" accept=".json" style="display: none" />
    </div>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.32.1/babylon.js"></script> -->
    <!-- v6 -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@6.32.1/babylon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-gui@6.32.1/babylon.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-materials@6.32.1/babylonjs.materials.min.js"></script>
  -->

    <!-- v7 -->
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@7.48.1/babylon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-gui@7.48.1/babylon.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-materials@7.48.1/babylonjs.materials.min.js"></script>

    <script>
      class NaturalLandscape {
        static TERRAIN_CONFIG = {
          SIZE: 3000,
          SUBDIVISIONS: 250,
          HEIGHT_SCALE: 40,
          NOISE_SCALE: 0.002,
          COLOR: new BABYLON.Color3(0.5, 0.6, 0.3), // light green
          DIFFUSE_COLOR: new BABYLON.Color3(0, 0, 0),
        }

        static TOOL_CONFIG = {
          EDIT_RADIUS: 150, // midly large
          EDIT_STRENGTH: 20, // midly strong
        }

        static SEASON_CONFIG = {
          SPRING: {
            id: 0,
            lightIntensity: 0.7,
            lightDirection: new BABYLON.Vector3(0, 1, 0),
            lightColor: new BABYLON.Color3(1, 1, 1),
            dirLightColorIntensity: 0.6,
            dirLightDirection: new BABYLON.Vector3(0, -1, 0),
            dirLightColor: new BABYLON.Color3(0.65, 0.78, 0.58), // light blue
            groundColor: new BABYLON.Color3(0.52, 0.71, 0.46), // Bright spring green
            treeColors: [
              new BABYLON.Color3(0.3, 0.8, 0.2), // Fresh spring green
              new BABYLON.Color3(0.4, 0.8, 0.3),
              new BABYLON.Color3(0.5, 0.8, 0.2),
              new BABYLON.Color3(0.6, 0.9, 0.3),
              new BABYLON.Color3(0.7, 0.9, 0.2),
            ],
            treeDensity: 1.0, // Full foliage
            fogDensity: 0.00002, // Light spring mist
            fogColor: new BABYLON.Color3(0.52, 0.71, 0.46), // pure white
            skyConfig: {
              turbidity: 0.4, // Very clear sky
              luminance: 0.1, // Bright
              rayleigh: 0.5, // Deep blue
              mieCoefficient: 0.003,
              mieDirectionalG: 0.8,
              inclination: 0.65, // Highest sun
              azimuth: 0.25,
            },
          },
          SUMMER: {
            id: 1,
            lightIntensity: 1.3,
            lightDirection: new BABYLON.Vector3(1, 1, 0),
            lightColor: new BABYLON.Color3(0.88, 0.76, 0.69),
            dirLightColorIntensity: 0.6,
            dirLightDirection: new BABYLON.Vector3(0, -1, 0),
            dirLightColor: new BABYLON.Color3(0.31, 0.63, 0.43), // light blue
            groundColor: new BABYLON.Color3(0.59, 0.6, 0.3), // Warm summer brown
            treeColors: [
              new BABYLON.Color3(0.1, 0.6, 0.1),
              new BABYLON.Color3(0.8, 0.83, 0.14),
              new BABYLON.Color3(0.07, 0.47, 0.09),
              new BABYLON.Color3(0.2, 0.6, 0.2),
              new BABYLON.Color3(0.4, 0.7, 0.2),
            ],
            treeDensity: 1.0,
            fogDensity: 0.0001, // Clear summer air
            fogColor: new BABYLON.Color3(0.62, 0.79, 0.94), // pure white
            skyConfig: {
              turbidity: 1.9, // Very clear sky
              luminance: 0.001, // Bright
              rayleigh: 0.13, // Deep blue
              mieCoefficient: 0.005,
              mieDirectionalG: 0.98,
              inclination: 0.59, // Highest sun
              azimuth: 0.55,
            },
          },
          AUTUMN: {
            id: 2,
            lightIntensity: 1,
            lightDirection: new BABYLON.Vector3(-0.3, 0.5, 0),
            lightColor: new BABYLON.Color3(1, 0.87, 0.48),
            dirLightColorIntensity: 5,
            dirLightDirection: new BABYLON.Vector3(0, 1, 0),
            dirLightColor: new BABYLON.Color3(0.19, 0.15, 0.1), // yellow orange
            groundColor: new BABYLON.Color3(0.6, 0.5, 0.2), // Autumnal brown
            treeColors: [
              new BABYLON.Color3(0.8, 0.4, 0.1), // Orange
              new BABYLON.Color3(0.9, 0.3, 0.1), // Red
              new BABYLON.Color3(0.8, 0.6, 0.1), // Yellow
              //new BABYLON.Color3(0.7, 0.2, 0.1), // Dark red
              new BABYLON.Color3(0.18, 0.23, 0.13), // Dark green
              new BABYLON.Color3(0.6, 0.4, 0.1), // Brown
            ],
            treeDensity: 0.8, // Some leaves fallen
            fogDensity: 0.00045, // Autumn mist
            fogColor: new BABYLON.Color3(1, 1, 1), // pure white
            skyConfig: {
              turbidity: 0.9, // Very clear sky
              luminance: 0.001, // Bright
              rayleigh: 0.6, // Deep blue
              mieCoefficient: 0.003,
              mieDirectionalG: 0.8,
              inclination: 0.52, // Highest sun
              azimuth: 0.25,
            },
          },
          WINTER: {
            id: 3,
            lightIntensity: 1.2,
            lightDirection: new BABYLON.Vector3(0.3, 0.8, 0.3),
            lightColor: new BABYLON.Color3(1, 1, 1),
            dirLightColorIntensity: 1.5,
            dirLightDirection: new BABYLON.Vector3(0, 1, 0),
            dirLightColor: new BABYLON.Color3(0, 0, 0.3), // light blue
            groundColor: new BABYLON.Color3(0.9, 0.9, 0.9), // Snow white
            treeColors: [
              new BABYLON.Color3(0.2, 0.4, 0.1), // Dark evergreen
              new BABYLON.Color3(0.1, 0.3, 0.1),
              new BABYLON.Color3(0.2, 0.3, 0.1),
              new BABYLON.Color3(0.1, 0.2, 0.1),
              new BABYLON.Color3(1, 1, 1),
            ],

            treeDensity: 0.6, // Bare trees
            fogDensity: 0.0002, // Winter fog
            fogColor: new BABYLON.Color3(1, 1, 1), // pure white
            skyConfig: {
              turbidity: 3, // Most hazy
              luminance: 0.7, // Darker
              rayleigh: 5.0, // More scattered light (grayish)
              mieCoefficient: 0.015, // More particle scattering
              mieDirectionalG: 0.6,
              inclination: 0.4, // Lowest sun
              azimuth: 0.25,
            },
          },
        }

        static VEGETATION_CONFIG = {
          TREE_COUNT: 7000,
          TREE_HEIGHT: 10,
          TREE_TRUNK_DIAMETER: 3,
          TREE_TOP_HEIGHT: 40,
          TREE_TOP_DIAMETER: 0,
          TREE_BASE_DIAMETER: 15,
          TREE_NOISE_SCALE: 0.003,
          TREE_DENSITY_THRESHOLD: 0.6,
          TREE_ONLY_NOISE_SCALE: 0.001, // Smaller scale for larger tree-only zones
          TREE_ONLY_THRESHOLD: 0.7, // Higher threshold for exclusive tree zones
        }

        static ROCK_CONFIG = {
          ROCK_COUNT: 4000,
          MIN_SCALE: 10.5,
          MAX_SCALE: 30,
          ROCK_NOISE_SCALE: 0.005,
          ROCK_DENSITY_THRESHOLD: 0.55,
          MIXED_AREA_THRESHOLD: 0.4,
        }

        static CAMERA_CONFIG = {
          MIN_RADIUS: 500, // Minimum camera distance
          RADIUS: 1200, // Camera distance
          MAX_RADIUS: 3000, // Maximum camera distance
          IDLE_TIMEOUT: 10000, // 10 seconds
          ZOOM_SPEED: 0.25, // Zoom speed (adjust as needed)
        }

        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId)
          this.engine = new BABYLON.Engine(this.canvas, true)
          this.scene = new BABYLON.Scene(this.engine)

          // Add this line to track the selected tool size
          this.selectedToolSize = 150 // Default to medium size

          this.currentSeason = NaturalLandscape.SEASON_CONFIG.SUMMER

          // Initialize class properties
          this.light = null
          this.dirLight = null
          this.terrainMaterial = null
          this.skyMaterial = null
          this.skybox = null
          this.idleCamera = null
          this.camera = null

          // Store the active camera
          this.activeCamera = this.camera

          // Track user activity
          this.lastActivityTime = Date.now()
          this.idleTimeout = NaturalLandscape.CAMERA_CONFIG.IDLE_TIMEOUT // 10 seconds
          this.isIdle = false

          // Add event listeners for user activity
          this.canvas.addEventListener(
            'mousemove',
            this.resetIdleTimer.bind(this)
          )
          this.canvas.addEventListener(
            'touchstart',
            this.resetIdleTimer.bind(this)
          )
          this.canvas.addEventListener(
            'keydown',
            this.resetIdleTimer.bind(this)
          )

          // Track mouse interaction state
          this.isMouseDown = false

          // Add more comprehensive event listeners
          this.canvas.addEventListener('pointerdown', (event) => {
            // Check if left mouse button is pressed

            if (event.button === 0) {
              this.isMouseDown = true
              this.resetIdleTimer()
            }
          })

          this.canvas.addEventListener('pointerup', (event) => {
            // Reset mouse down state when button is released
            if (event.button === 0) {
              this.isMouseDown = false
            }
          })

          this.canvas.addEventListener('pointermove', (event) => {
            // Only reset timer if left mouse button is held down
            if (this.isMouseDown) {
              this.resetIdleTimer()
            }
          })

          // Add event listener to reset cursor when mouse leaves the canvas
          this.canvas.addEventListener('pointerleave', () => {
            this.updateCursor('default') // Reset cursor to default
          })

          // Start the idle check loop
          this.checkIdle()

          // Parse seed from URL or generate random
          const urlParams = new URLSearchParams(window.location.search)
          const seedParam = urlParams.get('seed')
          let seed
          if (seedParam !== null) {
            seed = isNaN(seedParam)
              ? stringToSeed(seedParam)
              : parseInt(seedParam)
          } else {
            seed = this.generateSeed()
          }

          console.log('seed : ' + seed)

          // Initialize PRNG
          this.prng = this.createPrng(seed)

          // Initialize permutation table with PRNG
          this.p = new Array(512)
          for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(this.prng() * 256)
          }
          for (let i = 0; i < 256; i++) {
            this.p[256 + i] = this.p[i]
          }

          // Add this new property to track if we're editing terrain
          this.isEditingTerrain = false
          this.lastMouseY = 0
          this.editRadius = 150
          this.editStrength = 20

          // Modify the canvas event listeners to prevent default right-click behavior
          this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault()
            e.stopPropagation()
          })

          // Update mouse handlers
          this.canvas.addEventListener('pointerdown', (e) => {
            if (e.button === 2) {
              // Right mouse button
              e.preventDefault()
              this.isEditingTerrain = true
              this.lastMouseY = e.clientY
              this.updateCursor('ns-resize') // Change cursor to ns-resize
            }
          })

          // Update the pointerup event listener
          this.canvas.addEventListener('pointerup', (e) => {
            if (e.button === 2) {
              // Right mouse button
              e.preventDefault()
              this.isEditingTerrain = false
              this.updateCursor('default') // Reset cursor to default
            }
          })

          this.canvas.addEventListener('pointermove', (e) => {
            if (this.isEditingTerrain) {
              const deltaY = e.clientY - this.lastMouseY
              this.lastMouseY = e.clientY
              this.modifyTerrainElevation(e.clientX, e.clientY, -deltaY * 0.1)
              this.updateCursor('ns-resize') // Change cursor to ns-resize
            }
            if (e.button === 2) {
              this.updateCursor('ns-resize') // Change cursor to ns-resize
            }
          })
        }

        // Add this method to handle cursor change
        updateCursor(cursorStyle) {
          this.canvas.style.cursor = cursorStyle
        }

        generateSeed() {
          return Math.floor(Math.random() * 0xffffffff)
        }

        resetLandscape() {
          // Store the current camera parameters
          const cameraPosition = this.camera.position.clone()
          const cameraRotation = this.camera.rotation.clone()
          const cameraRadius = this.camera.radius
          const cameraTarget = this.camera.target.clone()

          // Dispose of the current scene
          this.scene.dispose()

          // Reinitialize the scene with the same seed
          this.scene = new BABYLON.Scene(this.engine)
          this.initializePRNG(this.seed)

          // Recreate the scene
          this.createScene()

          // Reapply the stored camera parameters
          this.camera.position = cameraPosition
          this.camera.rotation = cameraRotation
          this.camera.radius = cameraRadius
          this.camera.setTarget(cameraTarget)

          // Force the camera to update its view
          this.camera.setTarget(BABYLON.Vector3.Zero())
        }

        randomLandscape() {
          // Store the current camera parameters
          const cameraPosition = this.camera.position.clone()
          const cameraRotation = this.camera.rotation.clone()
          const cameraRadius = this.camera.radius
          const cameraTarget = this.camera.target.clone()

          // Dispose of the current scene
          this.scene.dispose()

          // Reinitialize the scene with the same seed
          this.scene = new BABYLON.Scene(this.engine)
          this.initializePRNG(this.generateSeed())

          // Reset HEIGHT_SCALE to 101124U
          NaturalLandscape.TERRAIN_CONFIG.HEIGHT_SCALE = 1 + Math.random() * 50

          // Recreate the scene
          this.createScene()

          // Reapply the stored camera parameters
          this.camera.position = cameraPosition
          this.camera.rotation = cameraRotation
          this.camera.radius = cameraRadius
          this.camera.setTarget(cameraTarget)

          // Force the camera to update its view
          this.camera.setTarget(BABYLON.Vector3.Zero())
        }

        modifyTerrainElevation(mouseX, mouseY, strength) {
          const pickResult = this.scene.pick(
            mouseX,
            mouseY,
            (mesh) => mesh.name === 'ground'
          )
          if (!pickResult.hit) return

          const ground = pickResult.pickedMesh

          // Get the current vertex data
          const positions = ground.getVerticesData(
            BABYLON.VertexBuffer.PositionKind
          )
          const indices = ground.getIndices()

          // Find affected vertices within radius
          const pickedPoint = pickResult.pickedPoint
          const affectedVertices = []

          for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i]
            const z = positions[i + 2]
            const distance = Math.sqrt(
              (x - pickedPoint.x) ** 2 + (z - pickedPoint.z) ** 2
            )

            if (distance < this.editRadius) {
              affectedVertices.push(i + 1) // Store indices of Y coordinates
            }
          }

          // Modify vertex heights
          let modified = false
          affectedVertices.forEach((index) => {
            const falloff =
              1 -
              Math.sqrt(
                (positions[index - 1] - pickedPoint.x) ** 2 +
                  (positions[index + 1] - pickedPoint.z) ** 2
              ) /
                this.editRadius

            positions[index] += strength * falloff * this.editStrength
            modified = true
          })

          if (modified) {
            // Recompute normals
            const normals = new Float32Array(positions.length)
            BABYLON.VertexData.ComputeNormals(positions, indices, normals)

            // Update positions and normals
            ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions)
            ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals)

            // Force the mesh to update
            ground.refreshBoundingInfo()
            ground.computeWorldMatrix(true)

            // Update vegetation and rocks after terrain modification
            this.updateObjectsElevation(ground, pickedPoint, positions)
          }
        }

        updateObjectsElevation(groundMesh, pickedPoint, positions) {
          const affectedObjects = []

          // Collect nearby trees and rocks
          this.scene.meshes.forEach((mesh) => {
            if (
              mesh.name.startsWith('trunkInstance') ||
              mesh.name.startsWith('rock')
            ) {
              const distance = BABYLON.Vector3.Distance(
                mesh.position,
                pickedPoint
              )
              if (distance < this.editRadius) {
                affectedObjects.push(mesh)
              }
            }
          })

          // Update positions
          affectedObjects.forEach((obj) => {
            const newY = this.getHeightFromTerrain(
              obj.position.x,
              obj.position.z,
              groundMesh,
              positions
            )
            obj.position.y = newY

            // Update leaves for trees
            if (obj.name.startsWith('trunkInstance')) {
              const leavesName = obj.name.replace(
                'trunkInstance',
                'leavesInstance'
              )
              const leaves = this.scene.getMeshByName(leavesName)
              if (leaves) {
                const trunkHeight =
                  NaturalLandscape.VEGETATION_CONFIG.TREE_HEIGHT * obj.scaling.y
                const leavesHeight =
                  NaturalLandscape.VEGETATION_CONFIG.TREE_TOP_HEIGHT *
                  leaves.scaling.y
                leaves.position.y = newY + trunkHeight / 2 + leavesHeight / 2
              }
            }
          })
        }

        // Helper method to calculate terrain height
        calculateTerrainHeight(x, z, noiseScale, heightScale) {
          const nx = x * noiseScale
          const nz = z * noiseScale
          return (
            this.generateNoise(nx, nz) * heightScale +
            this.generateNoise(nx * 2, nz * 2) * (heightScale / 2) +
            this.generateNoise(nx * 4, nz * 4) * (heightScale / 4)
          )
        }

        getHeightFromTerrain(x, z, groundMesh, positions) {
          const subdivisions = NaturalLandscape.TERRAIN_CONFIG.SUBDIVISIONS
          const size = NaturalLandscape.TERRAIN_CONFIG.SIZE

          // Convert to grid coordinates
          const gridX = (x / size + 0.5) * subdivisions
          const gridZ = (z / size + 0.5) * subdivisions

          const x0 = Math.floor(gridX)
          const x1 = x0 + 1
          const z0 = Math.floor(gridZ)
          const z1 = z0 + 1

          // Clamp indices
          if (x0 < 0 || x1 > subdivisions || z0 < 0 || z1 > subdivisions)
            return 0

          // Get vertex indices
          const idx00 = (z0 * (subdivisions + 1) + x0) * 3
          const idx01 = (z0 * (subdivisions + 1) + x1) * 3
          const idx10 = (z1 * (subdivisions + 1) + x0) * 3
          const idx11 = (z1 * (subdivisions + 1) + x1) * 3

          // Bilinear interpolation
          const dx = gridX - x0
          const dz = gridZ - z0

          const y00 = positions[idx00 + 1]
          const y01 = positions[idx01 + 1]
          const y10 = positions[idx10 + 1]
          const y11 = positions[idx11 + 1]

          const y0 = y00 * (1 - dx) + y01 * dx
          const y1 = y10 * (1 - dx) + y11 * dx
          return y0 * (1 - dz) + y1 * dz
        }

        // New helper method to create mesh templates
        createMeshTemplate(config) {
          const { name, type, material, parameters } = config
          let template

          if (type === 'cylinder') {
            template = BABYLON.MeshBuilder.CreateCylinder(
              name,
              parameters,
              this.scene
            )
          } else if (type === 'polyhedron') {
            template = BABYLON.MeshBuilder.CreatePolyhedron(
              name,
              parameters,
              this.scene
            )
          }

          template.material = material
          template.setEnabled(false)
          return template
        }

        // New helper method to create materials
        createMaterials(configs) {
          return configs.map(({ name, color }) => {
            const material = new BABYLON.StandardMaterial(name, this.scene)
            material.diffuseColor = color
            return material
          })
        }

        // New helper method to create mesh instances
        createMeshInstance(template, instanceConfig) {
          const { name, position, rotation, scaling } = instanceConfig
          const instance = template.createInstance(name)

          if (position) instance.position = BABYLON.Vector3.FromArray(position)
          if (rotation) instance.rotation = BABYLON.Vector3.FromArray(rotation)
          if (scaling) instance.scaling = BABYLON.Vector3.FromArray(scaling)

          return instance
        }

        // Refactored method to create vegetation templates
        createVegetationTemplates() {
          // Create trunk material and template
          const trunkMaterial = new BABYLON.StandardMaterial(
            'trunkMat',
            this.scene
          )
          trunkMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.1)

          const trunkTemplate = this.createMeshTemplate({
            name: 'trunkTemplate',
            type: 'cylinder',
            material: trunkMaterial,
            parameters: {
              height: NaturalLandscape.VEGETATION_CONFIG.TREE_HEIGHT,
              diameter: NaturalLandscape.VEGETATION_CONFIG.TREE_TRUNK_DIAMETER,
            },
          })

          // Create leaf materials and templates
          const leafMaterials = this.createMaterials(
            this.currentSeason.treeColors.map((color, i) => ({
              name: `leavesMat${i}`,
              color,
            }))
          )

          const leafTemplates = leafMaterials.map((material, i) =>
            this.createMeshTemplate({
              name: `leavesTemplate${i}`,
              type: 'cylinder',
              material,
              parameters: {
                height: NaturalLandscape.VEGETATION_CONFIG.TREE_TOP_HEIGHT,
                diameter: NaturalLandscape.VEGETATION_CONFIG.TREE_BASE_DIAMETER,
                diameterTop:
                  NaturalLandscape.VEGETATION_CONFIG.TREE_TOP_DIAMETER,
              },
            })
          )

          return { trunkTemplate, leafTemplates }
        }

        createRockTemplate() {
          const rockMaterial = new BABYLON.StandardMaterial(
            'rockMat',
            this.scene
          )
          rockMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6)

          const rockTemplate = this.createMeshTemplate({
            name: 'rockTemplate',
            type: 'polyhedron',
            material: rockMaterial,
            parameters: { type: 2, size: 1 },
          })

          return rockTemplate
        }

        createScene() {
          this.camera = new BABYLON.ArcRotateCamera(
            'camera',
            Math.PI + 0.4,
            Math.PI / 2.2,
            NaturalLandscape.CAMERA_CONFIG.RADIUS,
            BABYLON.Vector3.Zero(),
            this.scene
          )

          // Disable right-click panning
          this.camera.inputs.attached.pointers.buttons = [0, 1] // Only left button and middle button
          // Set the zoom speed
          this.camera.inputs.attached.mousewheel.wheelPrecision =
            NaturalLandscape.CAMERA_CONFIG.ZOOM_SPEED

          this.camera.attachControl(this.canvas, true)
          this.camera.lowerRadiusLimit =
            NaturalLandscape.CAMERA_CONFIG.MIN_RADIUS
          this.camera.upperRadiusLimit =
            NaturalLandscape.CAMERA_CONFIG.MAX_RADIUS

          // Idle camera setup
          this.idleCamera = new BABYLON.ArcRotateCamera(
            'idleCamera',
            Math.PI + 0.4, // alpha (horizontal rotation)
            Math.PI / 2.2, // beta (vertical rotation, lowered to 45 degrees)
            NaturalLandscape.CAMERA_CONFIG.RADIUS, // radius
            BABYLON.Vector3.Zero(), // target (center of the scene)
            this.scene
          )

          this.idleCamera.lowerRadiusLimit =
            NaturalLandscape.CAMERA_CONFIG.RADIUS // Fixed radius
          this.idleCamera.upperRadiusLimit =
            NaturalLandscape.CAMERA_CONFIG.RADIUS // Fixed radius
          this.idleCamera.attachControl(this.canvas, false) // Disable controls for idle camera

          // Lighting setup - store references
          this.light = new BABYLON.HemisphericLight(
            'light',
            this.currentSeason.lightDirection,
            this.scene
          )
          this.light.intensity = this.currentSeason.lightIntensity
          this.light.diffuse = this.currentSeason.lightColor

          this.dirLight = new BABYLON.DirectionalLight(
            'dirLight',
            this.currentSeason.dirLightDirection,
            this.scene
          )
          this.dirLight.intensity = this.currentSeason.dirLightColorIntensity
          this.dirLight.diffuse = this.currentSeason.dirLightColor

          // Enable fog
          this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP
          this.scene.fogDensity = this.currentSeason.fogDensity
          this.scene.fogColor = this.currentSeason.fogColor

          this.createTerrain()
          this.addTrees()
          this.addRocks()

          // Add sky
          this.createSky()

          // Assuming you have a Babylon.js scene instance
          //this.scene.debugLayer.show()

          this.scene.onBeforeRenderObservable.add(() => {
            fpsCounter.textContent = this.engine.getFps().toFixed()
          })

          return this.scene
        }

        createTerrain() {
          const {
            SIZE,
            SUBDIVISIONS,
            HEIGHT_SCALE,
            NOISE_SCALE,
            COLOR,
            DIFFUSE_COLOR,
          } = NaturalLandscape.TERRAIN_CONFIG

          const terrainMaterial = new BABYLON.StandardMaterial(
            'terrainMat',
            this.scene
          )

          this.terrainMaterial = terrainMaterial
          this.terrainMaterial.diffuseColor = this.currentSeason.groundColor
          this.terrainMaterial.specularColor =
            NaturalLandscape.TERRAIN_CONFIG.DIFFUSE_COLOR

          const ground = new BABYLON.Mesh('ground', this.scene)
          const vertexData = new BABYLON.VertexData()
          const positions = []
          const indices = []
          const uvs = []

          // Generate mesh vertices
          for (let z = 0; z <= SUBDIVISIONS; z++) {
            for (let x = 0; x <= SUBDIVISIONS; x++) {
              const xPos = (x / SUBDIVISIONS - 0.5) * SIZE
              const zPos = (z / SUBDIVISIONS - 0.5) * SIZE

              const nx = xPos * NOISE_SCALE
              const nz = zPos * NOISE_SCALE
              let height = this.generateNoise(nx, nz) * HEIGHT_SCALE
              height += this.generateNoise(nx * 2, nz * 2) * (HEIGHT_SCALE / 2)
              height += this.generateNoise(nx * 4, nz * 4) * (HEIGHT_SCALE / 4)

              positions.push(xPos, height, zPos)
              uvs.push(x / SUBDIVISIONS, z / SUBDIVISIONS)
            }
          }

          // Generate indices
          for (let z = 0; z < SUBDIVISIONS; z++) {
            for (let x = 0; x < SUBDIVISIONS; x++) {
              const bottomLeft = z * (SUBDIVISIONS + 1) + x
              const bottomRight = bottomLeft + 1
              const topLeft = (z + 1) * (SUBDIVISIONS + 1) + x
              const topRight = topLeft + 1

              indices.push(bottomLeft, bottomRight, topRight)
              indices.push(bottomLeft, topRight, topLeft)
            }
          }

          const normals = []
          BABYLON.VertexData.ComputeNormals(positions, indices, normals)

          vertexData.positions = positions
          vertexData.indices = indices
          vertexData.normals = normals
          vertexData.uvs = uvs
          vertexData.applyToMesh(ground)

          ground.material = terrainMaterial
          ground.receiveShadows = false
        }

        // Refactored addTrees method
        addTrees() {
          const { trunkTemplate, leafTemplates } =
            this.createVegetationTemplates()
          const {
            TREE_COUNT,
            TREE_HEIGHT,
            TREE_TOP_HEIGHT,
            TREE_NOISE_SCALE,
            TREE_DENSITY_THRESHOLD,
            TREE_ONLY_NOISE_SCALE,
            TREE_ONLY_THRESHOLD,
          } = NaturalLandscape.VEGETATION_CONFIG
          const { SIZE, HEIGHT_SCALE, NOISE_SCALE } =
            NaturalLandscape.TERRAIN_CONFIG

          let treesPlaced = 0
          while (treesPlaced < TREE_COUNT) {
            const x = this.prng() * SIZE - SIZE / 2
            const z = this.prng() * SIZE - SIZE / 2

            const treeDensity =
              (this.generateNoise(x * TREE_NOISE_SCALE, z * TREE_NOISE_SCALE) +
                1) /
              2
            const treeOnlyDensity =
              (this.generateNoise(
                x * TREE_ONLY_NOISE_SCALE,
                z * TREE_ONLY_NOISE_SCALE
              ) +
                1) /
              2
            const height = this.calculateTerrainHeight(
              x,
              z,
              NOISE_SCALE,
              HEIGHT_SCALE
            )

            if (
              (treeOnlyDensity > TREE_ONLY_THRESHOLD ||
                treeDensity > TREE_DENSITY_THRESHOLD) &&
              height > HEIGHT_SCALE * 0.1
            ) {
              const scale = 0.8 + this.prng() * 0.4
              const rotation = this.prng() * Math.PI * 2

              // Create trunk instance
              const trunkInstance = this.createMeshInstance(trunkTemplate, {
                name: `trunkInstance${treesPlaced}`,
                position: [x, height, z],
                rotation: [0, rotation, 0],
                scaling: [scale, scale, scale],
              })

              // Select and create leaves instance
              const leafTemplate = leafTemplates[Math.floor(this.prng() * 5)]
              const leafTemplateIndex = leafTemplates.indexOf(leafTemplate)
              trunkInstance.userData = { leafTemplateIndex }

              const trunkScaledHeight = TREE_HEIGHT * scale
              const leavesScaledHeight = TREE_TOP_HEIGHT * scale
              const leavesY =
                height + trunkScaledHeight / 2 + leavesScaledHeight / 2

              this.createMeshInstance(leafTemplate, {
                name: `leavesInstance${treesPlaced}`,
                position: [x, leavesY, z],
                rotation: [0, rotation, 0],
                scaling: [scale, scale, scale],
              })

              treesPlaced++
            }
          }
        }

        // Refactored addRocks method
        addRocks() {
          const rockMaterial = new BABYLON.StandardMaterial(
            'rockMat',
            this.scene
          )
          rockMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6)

          const rockTemplate = this.createMeshTemplate({
            name: 'rockTemplate',
            type: 'polyhedron',
            material: rockMaterial,
            parameters: { type: 2, size: 1 },
          })

          const {
            ROCK_COUNT,
            MIN_SCALE,
            MAX_SCALE,
            ROCK_NOISE_SCALE,
            ROCK_DENSITY_THRESHOLD,
            MIXED_AREA_THRESHOLD,
          } = NaturalLandscape.ROCK_CONFIG
          const { SIZE, HEIGHT_SCALE, NOISE_SCALE } =
            NaturalLandscape.TERRAIN_CONFIG

          const {
            TREE_COUNT,
            TREE_HEIGHT,
            TREE_TOP_HEIGHT,
            TREE_NOISE_SCALE,
            TREE_DENSITY_THRESHOLD,
            TREE_ONLY_NOISE_SCALE,
            TREE_ONLY_THRESHOLD,
          } = NaturalLandscape.VEGETATION_CONFIG

          let rocksPlaced = 0
          while (rocksPlaced < ROCK_COUNT) {
            const x = this.prng() * SIZE - SIZE / 2
            const z = this.prng() * SIZE - SIZE / 2

            const rockDensity =
              (this.generateNoise(x * ROCK_NOISE_SCALE, z * ROCK_NOISE_SCALE) +
                1) /
              2
            const mixedDensity =
              (this.generateNoise(x * 0.0025, z * 0.0025) + 1) / 2
            const treeOnlyDensity =
              (this.generateNoise(
                x * TREE_ONLY_NOISE_SCALE,
                z * TREE_ONLY_NOISE_SCALE
              ) +
                1) /
              2
            const height = this.calculateTerrainHeight(
              x,
              z,
              NOISE_SCALE,
              HEIGHT_SCALE
            )

            if (
              treeOnlyDensity < TREE_ONLY_THRESHOLD &&
              (rockDensity > ROCK_DENSITY_THRESHOLD ||
                (mixedDensity > MIXED_AREA_THRESHOLD && this.prng() > 0.7)) &&
              height > HEIGHT_SCALE * 0.15
            ) {
              this.createMeshInstance(rockTemplate, {
                name: `rockInstance${rocksPlaced}`,
                position: [x, height, z],
                rotation: [
                  this.prng() * Math.PI,
                  this.prng() * Math.PI,
                  this.prng() * Math.PI,
                ],
                scaling: Array(3)
                  .fill()
                  .map(() => MIN_SCALE + this.prng() * (MAX_SCALE - MIN_SCALE)),
              })

              rocksPlaced++
            }
          }
        }

        updateTrees() {
          const leafInstances = this.scene.meshes.filter((mesh) =>
            mesh.name.startsWith('leavesTemplate')
          )

          leafInstances.forEach((leaves, index) => {
            const colorIndex = index % 5
            const material = new BABYLON.StandardMaterial(
              `leaves${index}`,
              this.scene
            )

            material.diffuseColor = this.currentSeason.treeColors[colorIndex]
            leaves.material = material
          })
        }

        createSky() {
          // Create the skybox
          this.skybox = BABYLON.MeshBuilder.CreateBox(
            'skyBox',
            { size: 10000.0 },
            this.scene
          )

          // Create and configure sky material
          this.skyMaterial = new BABYLON.SkyMaterial('skyMaterial', this.scene)
          this.skyMaterial.backFaceCulling = false

          // Apply material to skybox
          this.skybox.material = this.skyMaterial

          // Ensure skybox follows the camera
          this.skybox.infiniteDistance = true

          // Make sure the skybox is rendered first
          this.skybox.renderingGroupId = 0

          // Disable skybox from being pickable
          this.skybox.isPickable = false

          // Initialize with current season's sky configuration
          this.updateSkyConfig(this.currentSeason.skyConfig)

          // Position the skybox at the scene origin
          this.skybox.position = BABYLON.Vector3.Zero()
        }

        resetIdleTimer() {
          this.lastActivityTime = Date.now()
          if (this.isIdle) {
            this.switchToMainCamera()
          }
        }

        checkIdle() {
          const now = Date.now()
          if (now - this.lastActivityTime > this.idleTimeout && !this.isIdle) {
            // Add animation to the idle camera
            this.animateIdleCamera()
            this.switchToIdleCamera()
          }
          requestAnimationFrame(this.checkIdle.bind(this))
        }

        switchToIdleCamera() {
          this.isIdle = true
          this.activeCamera = this.idleCamera
          this.scene.activeCamera = this.idleCamera
        }

        switchToMainCamera() {
          this.isIdle = false
          this.activeCamera = this.camera
          this.scene.activeCamera = this.camera
        }

        animateIdleCamera() {
          let angle = this.camera.alpha
          const speed = 0.001 // Adjust speed as needed

          this.scene.registerBeforeRender(() => {
            if (this.isIdle) {
              angle += speed
              this.idleCamera.alpha = angle // Rotate around the center
              this.idleCamera.beta = Math.PI / 2.2
            }
          })
        }

        setSeason(season) {
          this.currentSeason = season
          this.updateSeasonalEffects()
        }

        updateSeasonalEffects() {
          if (!this.light || !this.terrainMaterial) {
            console.warn(
              'Scene not fully initialized. Call createScene() first.'
            )
            return
          }

          // Update lighting
          this.light.intensity = this.currentSeason.lightIntensity
          this.light.direction = this.currentSeason.lightDirection
          this.light.diffuse = this.currentSeason.lightColor

          this.dirLight.intensity = this.currentSeason.dirLightColorIntensity
          this.dirLight.direction = this.currentSeason.dirLightDirection
          this.dirLight.diffuse = this.currentSeason.dirLightColor

          // Update ground material
          this.terrainMaterial.diffuseColor = this.currentSeason.groundColor

          // Update fog
          this.scene.fogDensity = this.currentSeason.fogDensity
          this.scene.fogColor = this.currentSeason.fogColor

          // Update sky
          this.updateSkyConfig(this.currentSeason.skyConfig)

          // Update trees
          this.updateTrees()
        }

        // Get current season value
        getCurrentSeason() {
          return this.currentSeason
        }

        updateSkyConfig(config) {
          if (!this.skyMaterial) return

          // Basic parameters
          this.skyMaterial.turbidity = config.turbidity
          this.skyMaterial.luminance = config.luminance
          this.skyMaterial.rayleigh = config.rayleigh
          this.skyMaterial.mieCoefficient = config.mieCoefficient
          this.skyMaterial.mieDirectionalG = config.mieDirectionalG

          // Set sun position
          this.skyMaterial.useSunPosition = true
          const distance = 10000
          const theta = Math.PI * (config.inclination - 0.5)
          const phi = 2 * Math.PI * (config.azimuth - 0.5)

          const sunPosition = new BABYLON.Vector3(
            distance * Math.cos(phi),
            distance * Math.sin(theta),
            distance * Math.sin(phi)
          )
          this.skyMaterial.sunPosition = sunPosition

          // Force the sky material to update
          //this.skyMaterial.updateShaderUniforms()
        }

        // Get all available seasons
        getAvailableSeasons() {
          return Object.keys(NaturalLandscape.SEASON_CONFIG).map(
            (seasonKey) => ({
              name: seasonKey,
              config: NaturalLandscape.SEASON_CONFIG[seasonKey],
            })
          )
        }

        saveScene() {
          const ground = this.scene.getMeshByName('ground')
          const terrainVertices = ground
            ? ground.getVerticesData(BABYLON.VertexBuffer.PositionKind)
            : null

          // Function to round numbers to 3 decimal places
          const roundToThree = (num) => Math.round(num * 1000) / 1000

          const trees = []
          this.scene.meshes.forEach((mesh) => {
            if (mesh.name.startsWith('trunkInstance')) {
              const leaves = this.scene.getMeshByName(
                mesh.name.replace('trunkInstance', 'leavesInstance')
              )

              // Ensure that the leafTemplateIndex is correctly stored in userData
              const leafTemplateIndex = mesh.userData?.leafTemplateIndex || 0

              trees.push({
                position: mesh.position.asArray().map(roundToThree), // Round position
                rotation: mesh.rotation.asArray().map(roundToThree), // Round rotation
                scaling: mesh.scaling.asArray().map(roundToThree), // Round scaling
                leafTemplateIndex: leafTemplateIndex, // Ensure this is correctly stored
                leavesPosition: leaves
                  ? leaves.position.asArray().map(roundToThree)
                  : null, // Save leaves position
                leavesRotation: leaves
                  ? leaves.rotation.asArray().map(roundToThree)
                  : null, // Save leaves rotation
                leavesScaling: leaves
                  ? leaves.scaling.asArray().map(roundToThree)
                  : null, // Save leaves scaling
              })
            }
          })

          const rocks = []
          this.scene.meshes.forEach((mesh) => {
            if (mesh.name.startsWith('rockInstance')) {
              rocks.push({
                position: mesh.position.asArray().map(roundToThree), // Round position
                rotation: mesh.rotation.asArray().map(roundToThree), // Round rotation
                scaling: mesh.scaling.asArray().map(roundToThree), // Round scaling
              })
            }
          })

          // Round terrain vertices if they exist
          const roundedTerrainVertices = terrainVertices
            ? Array.from(terrainVertices).map(roundToThree)
            : null

          return {
            seed: this.seed,
            terrainVertices: roundedTerrainVertices,
            trees: trees,
            rocks: rocks,
            seasonId: this.currentSeason.id,
          }
        }

        // Refactored loadScene method
        loadScene(data) {
          // Reset and initialize scene
          this.scene.dispose()
          this.scene = new BABYLON.Scene(this.engine)
          this.initializePRNG(data.seed)
          this.createScene()

          this.setSeason(
            Object.values(NaturalLandscape.SEASON_CONFIG).find(
              (s) => s.id === data.seasonId
            )
          )

          // Apply terrain modifications
          if (data.terrainVertices) {
            this.applyTerrainModifications(data.terrainVertices)
          }

          // Clear existing objects
          this.removeTrees()
          this.removeRocks()

          // Create templates
          const { trunkTemplate, leafTemplates } =
            this.createVegetationTemplates()

          const rockTemplate = this.createRockTemplate()

          // Restore trees and rocks
          data.trees.forEach((tree, idx) => {
            const trunk = this.createMeshInstance(trunkTemplate, {
              name: `trunkInstance${idx}`,
              position: tree.position,
              rotation: tree.rotation,
              scaling: tree.scaling,
            })
            trunk.userData = { leafTemplateIndex: tree.leafTemplateIndex }

            this.createMeshInstance(leafTemplates[tree.leafTemplateIndex], {
              name: `leavesInstance${idx}`,
              position: tree.leavesPosition,
              rotation: tree.leavesRotation,
              scaling: tree.leavesScaling,
            })
          })

          data.rocks.forEach((rock, idx) => {
            this.createMeshInstance(rockTemplate, {
              name: `rockInstance${idx}`,
              position: rock.position,
              rotation: rock.rotation,
              scaling: rock.scaling,
            })
          })

          // set the season button active
          switch (data.seasonId) {
            case 0:
              updateActiveSeasonButton('springButton')
              break
            case 1:
              updateActiveSeasonButton('summerButton')
              break
            case 20:
              updateActiveSeasonButton('autumnButton')
              break
            case 3:
              updateActiveSeasonButton('winterButton')
              break
          }
        }

        removeTrees() {
          const meshesToRemove = this.scene.meshes.filter(
            (mesh) =>
              mesh.name.startsWith('trunkInstance') ||
              mesh.name.startsWith('leavesInstance')
          )

          meshesToRemove.forEach((mesh) => {
            if (mesh.material) {
              mesh.material.dispose() // Dispose of the material
            }
            this.scene.removeMesh(mesh) // Explicitly remove the mesh from the scene
            mesh.dispose() // Dispose of the mesh
          })
        }

        removeRocks() {
          const meshesToRemove = this.scene.meshes.filter((mesh) =>
            mesh.name.startsWith('rockInstance')
          )

          meshesToRemove.forEach((mesh) => {
            if (mesh.material) {
              mesh.material.dispose() // Dispose of the material
            }
            this.scene.removeMesh(mesh) // Explicitly remove the mesh from the scene
            mesh.dispose() // Dispose of the mesh
          })
        }

        // Helper method to initialize PRNG
        initializePRNG(seed) {
          this.seed = seed
          this.prng = this.createPrng(this.seed)
          this.p = new Array(512)
          for (let i = 0; i < 256; i++)
            this.p[i] = Math.floor(this.prng() * 256)
          for (let i = 0; i < 256; i++) this.p[256 + i] = this.p[i]
        }

        // Helper method to apply terrain modifications
        applyTerrainModifications(terrainVertices) {
          const ground = this.scene.getMeshByName('ground')
          ground.setVerticesData(
            BABYLON.VertexBuffer.PositionKind,
            new Float32Array(terrainVertices)
          )

          const normals = []
          BABYLON.VertexData.ComputeNormals(
            ground.getVerticesData(BABYLON.VertexBuffer.PositionKind),
            ground.getIndices(),
            normals
          )
          ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals)
          ground.refreshBoundingInfo()
        }

        createPrng(seed) {
          let a = seed
          return () => {
            a |= 0
            a = (a + 0x6d2b79f5) | 0
            let t = Math.imul(a ^ (a >>> 15), 1 | a)
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296
          }
        }

        // Add seed parsing and PRNG initialization before the class
        stringToSeed(str) {
          let hash = 0
          for (let i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i)
            hash |= 0 // Convert to 32-bit integer
          }
          return hash
        }

        // Noise generation methods remain the same
        generateNoise(x, y) {
          const X = Math.floor(x) & 255
          const Y = Math.floor(y) & 255
          x -= Math.floor(x)
          y -= Math.floor(y)

          const u = this.fade(x)
          const v = this.fade(y)

          const A = this.p[X] + Y
          const B = this.p[X + 1] + Y

          return this.lerp(
            v,
            this.lerp(
              u,
              this.grad(this.p[A], x, y),
              this.grad(this.p[B], x - 1, y)
            ),
            this.lerp(
              u,
              this.grad(this.p[A + 1], x, y - 1),
              this.grad(this.p[B + 1], x - 1, y - 1)
            )
          )
        }

        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10)
        }
        lerp(t, a, b) {
          return a + t * (b - a)
        }
        grad(hash, x, y) {
          const h = hash & 15
          const grad = 1 + (h & 7)
          return (h & 8 ? -grad : grad) * x + (h & 4 ? -grad : grad) * y
        }

        animate() {
          this.engine.runRenderLoop(() => {
            this.scene.render()
          })
        }
      }

      function updateActiveSeasonButton(activeButtonId) {
        const activeButton = document.getElementById(activeButtonId)

        if (activeButton) {
          // Check if the button is already active
          if (activeButton.classList.contains('active')) {
            // If it's already active, deselect it
            activeButton.classList.remove('active')
          } else {
            // If it's not active, deselect all buttons first
            const seasonButtons = document.querySelectorAll('.season-button')
            seasonButtons.forEach((button) => button.classList.remove('active'))

            // Then select the clicked button
            activeButton.classList.add('active')
          }
        } else {
          console.error(`Element with ID ${activeButtonId} not found.`)
        }
      }

      // Initialize the scene
      window.addEventListener('DOMContentLoaded', () => {
        const loadingScreen = document.getElementById('loadingScreen')
        const fpsCounter = document.getElementById('fpsCounter')
        const landscape = new NaturalLandscape('renderCanvas')

        landscape.createScene()

        // Save button
        document.getElementById('saveButton').addEventListener('click', () => {
          const data = landscape.saveScene()
          const blob = new Blob([JSON.stringify(data)], {
            type: 'application/json',
          })
          const a = document.createElement('a')
          a.href = URL.createObjectURL(blob)
          a.download = 'terrain-save.json'
          a.click()
        })

        // Load button
        document
          .getElementById('loadFile')
          .addEventListener('change', function (e) {
            const file = e.target.files[0]
            const reader = new FileReader()
            reader.onload = function () {
              // Reapply the active tool size button
              const activeToolButton = document.querySelector(
                '.radius-button.active-tool'
              )

              landscape.loadScene(JSON.parse(this.result))

              if (activeToolButton) {
                activeToolButton.classList.add('active-tool')
              }
            }
            reader.readAsText(file)
          })

        document.getElementById('loadButton').addEventListener('click', () => {
          document.getElementById('loadFile').click()
        })

        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
          // Reapply the active tool size button
          const activeToolButton = document.querySelector(
            '.radius-button.active-tool'
          )

          landscape.resetLandscape()

          if (activeToolButton) {
            activeToolButton.classList.add('active-tool')
          }
        })

        // Random button
        document
          .getElementById('randomButton')
          .addEventListener('click', () => {
            // Reapply the active tool size button
            const activeToolButton = document.querySelector(
              '.radius-button.active-tool'
            )

            landscape.randomLandscape()

            if (activeToolButton) {
              activeToolButton.classList.add('active-tool')
            }
          })

        // Radius buttons (Tool Size)
        const radiusButtons = document.querySelectorAll('.radius-button')
        radiusButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const radius = parseInt(button.getAttribute('data-radius'))
            landscape.editRadius = radius

            // Highlight the selected tool size button
            radiusButtons.forEach((btn) => btn.classList.remove('active-tool'))
            button.classList.add('active-tool')
          })
        })

        // Load/Reset/Random buttons (Actions)
        const actionButtons = document.querySelectorAll(
          '.save-load-controls .action-button'
        )

        actionButtons.forEach((button) => {
          button.addEventListener('click', () => {
            // Highlight the clicked action button
            actionButtons.forEach((btn) =>
              btn.classList.remove('active-action')
            )
            button.classList.add('active-action')
            landscape.updateCursor('default')
          })
        })

        // Initialize default active tool size button
        document
          .querySelector('.radius-button.medium')
          .classList.add('active-tool')

        // Initialize default active action button (if needed)
        document.getElementById('resetButton').classList.add('active-action')

        // Helper function to reapply the selected tool size
        function reapplyToolSize() {
          const radiusButtons = document.querySelectorAll('.radius-button')
          radiusButtons.forEach((button) => {
            const radius = parseInt(button.getAttribute('data-radius'))
            if (radius === landscape.selectedToolSize) {
              button.classList.add('active-tool')
            } else {
              button.classList.remove('active-tool')
            }
          })
        }

        // Season buttons event listeners
        document
          .getElementById('springButton')
          .addEventListener('click', () => {
            landscape.setSeason(NaturalLandscape.SEASON_CONFIG.SPRING)
            updateActiveSeasonButton('springButton')
          })

        document
          .getElementById('summerButton')
          .addEventListener('click', () => {
            landscape.setSeason(NaturalLandscape.SEASON_CONFIG.SUMMER)
            updateActiveSeasonButton('summerButton')
          })

        document
          .getElementById('autumnButton')
          .addEventListener('click', () => {
            landscape.setSeason(NaturalLandscape.SEASON_CONFIG.AUTUMN)
            updateActiveSeasonButton('autumnButton')
          })

        document
          .getElementById('winterButton')
          .addEventListener('click', () => {
            landscape.setSeason(NaturalLandscape.SEASON_CONFIG.WINTER)
            updateActiveSeasonButton('winterButton')
          })

        // Initialize the default active season button
        updateActiveSeasonButton('summerButton')

        document.getElementById('fpsCounter').addEventListener('click', () => {
          landscape.scene.debugLayer.show()
        })

        landscape.scene.executeWhenReady(() => {
          loadingScreen.style.display = 'none'
          landscape.animate()
        })

        window.addEventListener('resize', () => {
          landscape.engine.resize()
        })

        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            landscape.engine.stopRenderLoop()
          } else {
            landscape.animate()
          }
        })

        window.addEventListener('orientationchange', () => {
          setTimeout(() => {
            landscape.engine.resize()
          }, 200)
        })

        landscape.canvas.addEventListener(
          'touchmove',
          (e) => {
            e.preventDefault()
          },
          { passive: false }
        )

        // By default, seasons goes
        cycleThroughSeasons()

        // You can also create a simple season cycling function
        function cycleThroughSeasons() {
          const seasons = landscape.getAvailableSeasons()
          let currentIndex = 0

          // only if no season selected

          setInterval(() => {
            currentIndex = (currentIndex + 1) % seasons.length

            activeSeasonButton = document.querySelector('.season-button.active')
            if (!activeSeasonButton) {
              landscape.setSeason(
                NaturalLandscape.SEASON_CONFIG[seasons[currentIndex].name]
              )
            }
          }, 10000) // Change every 10 seconds
        }
      })
    </script>
  </body>
</html>
